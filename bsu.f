!
!
      real*8 function bsu(jj,kk,ll)
      implicit integer (i-n), real*8 (a-h,o-z)
      save
      include 'param.h'
      include 'comm.h'
!      dimension f_(0:iy+1,0:jx+1,ngen,lrz)
!      f_ is passed in common
      allocatable :: bsu_s(:,:,:)
      
!.........................................................................
!     This routine is used to compute the skewing effect at the p/t bndry
!     due to the bootstrap effect. It is not used if bootcalc="disabled",
!     or if advnce="explicit" or if lrz=1
!     Subroutine bsu is for the upper theta tp-bndry at i=itu.  
!     There is also a separate subroutine bsl for the lower itl bndry.
!.........................................................................
! YuP[2019-12-12] migrated corrections from CQL3D-FOW version
!     YuP [2014-05-22] Corrected dfdr definition, and also rban.
!     The expansion of distr.func. f() is made over physical R (or r), 
!     as the banana width is evaluated in R (or r) [cm] distance.
!     So, we cannot use rz() grid as dr definition; rz can be rho=0:1,
!     or it can be a length [cm], depending on radcoord definition,
!     but still generally it is not the actual R.  
!     Below, rz() is changed to rpcon() grid for the definition of dr,
!     where rpcon is R at the outer-midplane point of flux surface.
!     Also, now we use half-banana-width (factor 0.45 in def. of rban)
!     which is further used in evaluation of df = (df/dr)*rban .
!     (Not clear why 0.45, but it gives the best fit.)
!     Test/results (): There is a much better fit between 
!     numerical (bsu/bsl) results and Sauter et al '99 formula (jhirsh=99).
!     The profiles generated by bootcalc='method1' follow profiles 
!     given by jhirsh=99 formula; this is tested with different radcoord
!     values.  Yet, the total current from bootcalc='method1' 
!     is still 5-35% higher, depending on particular equilibrium.
!     Could be inaccuracy in banana width definition?
!     

      bsu=0.
      if (bootcalc.eq."disabled") return
      if (implct.ne."enabled" .or. lrz.eq.1 .or. n.lt.nonboot) return
      if (jj.le.2) return ! YuP[07-24-2014] added: 
                          ! df/dtheta should be 0 for j=1 and 2,
                          ! so do not apply bootstrap modifications

      if (.NOT. ALLOCATED(bsu_s)) then
        allocate( bsu_s(0:jx+1,lrz,ngen) )
        call bcast(bsu_s,zero,(jx+2)*lrz*ngen)
      endif

      qb_mc=bnumb(kk)*charge*bthr(ll)/(fmass(kk)*clight)

      jjj=max(jj,1)   ! to limit from below, for x(jjj)
      jjj=min(jjj,jx) ! to limit from above, for x(jjj)
      rban= 0.45*cursign*x(jjj)*coss(itu_(ll),ll)*vnorm/qb_mc
      ! YuP [140522] factor 0.5 added in rban

      if (bootcalc.eq."method1") then

        if (n.eq.nonboot.or.bootupdt.eq."enabled") then
          if (ll.eq.1) then
!            dfdr=(f_(itu_(ll+1),jj,kk,ll+1)-f_(itu_(ll),jj,kk,ll))/
!     &      (rz(ll+1)-rz(ll))
             p1=rpcon(ll+1)-rpcon(ll)
             p2=rpcon(ll+2)-rpcon(ll+1)
             p3=rpcon(ll+2)-rpcon(ll)
!             p1= (rpcon(ll+1)-rpcon(ll)   + rmcon(ll)-rmcon(ll+1)  )*0.5
!             p2= (rpcon(ll+2)-rpcon(ll+1) + rmcon(ll+1)-rmcon(ll+2))*0.5
!             p3= (rpcon(ll+2)-rpcon(ll)   + rmcon(ll)-rmcon(ll+2)  )*0.5
             dfdr=-(p1+p3)/(p1*p3)*f_(itu_(ll),jj,kk,ll)
     &            +p3/(p1*p2)*f_(itu_(ll+1),jj,kk,ll+1)
     &            -p1/(p2*p3)*f_(itu_(ll+2),jj,kk,ll+2)
          elseif (ll.eq.lrz) then
!            dfdr=(f_(itu_(ll),jj,kk,ll)-f_(itu_(ll-1),jj,kk,ll-1))/
!     &      (rz(ll)-rz(ll-1))
             p1=rpcon(ll-1)-rpcon(ll-2)
             p2=rpcon(ll)-rpcon(ll-1)
             p3=rpcon(ll)-rpcon(ll-2)
!             p1= (rpcon(ll-1)-rpcon(ll-2) + rmcon(ll-2)-rmcon(ll-1))*0.5
!             p2= (rpcon(ll)-rpcon(ll-1)   + rmcon(ll-1)-rmcon(ll)  )*0.5
!             p3= (rpcon(ll)-rpcon(ll-2)   + rmcon(ll-2)-rmcon(ll)  )*0.5
             dfdr=+p2/(p1*p3)*f_(itu_(ll-2),jj,kk,ll-2)
     &            -p3/(p1*p2)*f_(itu_(ll-1),jj,kk,ll-1)
     &            +(p2+p3)/(p2*p3)*f_(itu_(ll),jj,kk,ll)
          else ! 1<ll<lrz
             p1=rpcon(ll)-rpcon(ll-1)
             p2=rpcon(ll+1)-rpcon(ll)
             p3=rpcon(ll+1)-rpcon(ll-1)
!             p1= (rpcon(ll)-rpcon(ll-1)   + rmcon(ll-1)-rmcon(ll)  )*0.5
!             p2= (rpcon(ll+1)-rpcon(ll)   + rmcon(ll)-rmcon(ll+1)  )*0.5
!             p3= (rpcon(ll+1)-rpcon(ll-1) + rmcon(ll-1)-rmcon(ll+1))*0.5
!!             dfdr=-p2/(p1*p3)*f_(itu_(ll-1),jj,kk,ll-1)
!!     &            -(p1-p2)/(p1*p2)*f_(itu_(ll),jj,kk,ll)
!!     &            +p1/(p2*p3)*f_(itu_(ll+1),jj,kk,ll+1)
            dfdr=(f_(itu_(ll+1),jj,kk,ll+1)-f_(itu_(ll-1),jj,kk,ll-1))/
     &      p3 !-> same results as above dfdr, up to 4th digit
          endif
          bsu_=-bootsign*dfdr*rban
          bsu_s(jj,ll,kk)= bsu_ ! save into array
!          if(jj.eq.30 .and. (n.eq.nonboot .or. n.eq.4) )
!     &      write(*,'(a,2i3,e11.3,4e12.4)')
!     &     'kk,ll, dfdr, f_(ll=2,4,6,8)=',
!     &      kk,ll, dfdr, f_(itu_(2),jj,kk,2),f_(itu_(4),jj,kk,4),
!     &                   f_(itu_(6),jj,kk,6),f_(itu_(8),jj,kk,8)
        else  ! n>nonboot
          bsu_=bsu_s(jj,ll,kk) ! use saved array
        endif ! n.eq.nonboot

!     Limit the jump at trapped-passing boundary to 0.2*(distn functn).
!     If getting larger values, should probably at least consider
!     method2.  (BH).  
!     YuP: usually the jump is smaller: small change if skipped.
        bsum=abs(0.2*f_(itu_(ll),jj,kk,ll))
        bsu=sign(one,bsu_)*min(bsum,abs(bsu_))
           bsu=bsu_ ! uncomment to skip the above.

      elseif (bootcalc.eq."method2") then

!       Assuming positive current here (should be generalized).
        rrr=rpcon(ll)-rban ! rban carries the sign of vpar
        if(rrr.gt.MAXVAL(rlimiter)) then 
           ! out of plasma -> lost orbit
           f_irrr= 1.383896526737250d-87
           !f_irrr= f_(itu_(lrz),jj,kk,lrz) ! YuP[2019-12-13] not too diff.
           ! can be a large jump because of loss cone:
           bsu= f_irrr - f_(itu_(ll),jj,kk,ll)
        elseif(rpcon(ll)-abs(rban).lt.rmcon(1)) then 
           f_irrr= 1.383896526737250d-87
           ! No jump, for now. Orbits are too large 
           !(maybe no pinch orbits at all at small rho & large energy):
           bsu= 0.d0 !f_irrr - f_(itu_(ll),jj,kk,ll)
        else ! rmag<rrr<rpcon(lrzmax)
           rrr=max(rpcon(1),rrr) ! in case rmag<rrr<rpcon(1)
           call lookup(rrr,rpcon(1),lrzmax,weightu,weightl,irrr)
           f_irrr= weightl*f_(itu_(irrr-1),jj,kk,irrr-1)
     &            +weightu*f_(itu_(irrr),jj,kk,irrr)
           bsu= f_irrr - f_(itu_(ll),jj,kk,ll)
        endif
        bsu_s(jj,ll,kk)=bsu ! save into array 

      endif
      
      
      return     
      end function bsu

